<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>听雨亭</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>度义而后动，是而不见可悔故也</description>
    <pubDate>Mon, 27 Feb 2023 08:45:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>排序算法</title>
      <link>http://example.com/2023/02/27/%E6%8E%92%E5%BA%8F/</link>
      <guid>http://example.com/2023/02/27/%E6%8E%92%E5%BA%8F/</guid>
      <pubDate>Mon, 27 Feb 2023 08:15:57 GMT</pubDate>
      
        
        
      <description>&lt;hr&gt;
&lt;h2 id=&quot;一、快排&quot;&gt;&lt;a href=&quot;#一、快排&quot; class=&quot;headerlink&quot; title=&quot;一、快排&quot;&gt;&lt;/a&gt;一、快排&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1、快排的简述&quot;&gt;&lt;a href=&quot;#1、快排的简述&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<hr><h2 id="一、快排"><a href="#一、快排" class="headerlink" title="一、快排"></a>一、快排</h2><hr><h3 id="1、快排的简述"><a href="#1、快排的简述" class="headerlink" title="1、快排的简述"></a>1、快排的简述</h3><p>快排之所以快，是因为相对于冒泡排序，它可以是跳跃式的交换，而不再只有相邻的数的交换，但它也存在最差的情况，时间复杂度和冒泡排序是一样的，都是O(N^2),平均复杂度为O(NlogN)。 </p><h3 id="2、快排的实现"><a href="#2、快排的实现" class="headerlink" title="2、快排的实现"></a>2、快排的实现</h3><p>选取最左边的点为基准点，用到i，j两个变量，i在最左边，j在最右边，j向左移动，找到比基准值小的数停下，i向右移动，找到比基准值大的数停下，交换，直到i，j碰面，与基准值交换，然后递归处理左半边和右半边。 </p><h3 id="3、快排的代码实现"><a href="#3、快排的代码实现" class="headerlink" title="3、快排的代码实现"></a>3、快排的代码实现</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int n,i,j,a[100];  //定义全局变量   </span><br><span class="line"></span><br><span class="line">void quicksort(int left, int right)   </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">int temp,t;   //temp变量是基准，t变量是用来交换的第三变量  </span><br><span class="line">if(left &gt; right)   //跳出循环的第一个条件  </span><br><span class="line">&#123;  </span><br><span class="line">return;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">temp = a[left];   //此时选用的是第一个数当做基准 </span><br><span class="line">i = left; //i是1 </span><br><span class="line">j = right; //j是n </span><br><span class="line">while(i != j) //当i,j没有走到一块的时候 </span><br><span class="line">&#123;</span><br><span class="line">while(a[j] &gt;= temp &amp;&amp; i&lt;j)   //j一步一步左移，查找比基准值小的数 </span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">while(a[i] &lt;= temp &amp;&amp; i&lt;j)   //i一步一步右移，查找比基准值大的数 </span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">t = a[i];//将j查到的比基准值的数与i查到的比基准值小的数交换 </span><br><span class="line">a[i] = a[j];  //即将小的数放在基准值左边 </span><br><span class="line">a[j] = t;  //将大的数放在基准值右边 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  //将基准值归位 </span><br><span class="line">a[left] = a[i];//当循环结束时，i=j，在中间某一位置 </span><br><span class="line">a[i] = temp;  //将那一位置的数与基准值交换 </span><br><span class="line"></span><br><span class="line">//递归 ，将基准值左边分为一部分</span><br><span class="line">   //将基准值右边分为一部分 </span><br><span class="line">quicksort(left,i-1); //继续处理左半部分的数</span><br><span class="line">quicksort(i+1,right);   //继续处理右半部分的数  </span><br><span class="line">return ;  </span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></code></pre><hr><h2 id="二、桶排序"><a href="#二、桶排序" class="headerlink" title="二、桶排序"></a>二、桶排序</h2><hr><h3 id="1、桶排序的简述"><a href="#1、桶排序的简述" class="headerlink" title="1、桶排序的简述"></a>1、桶排序的简述</h3><p>桶排序是计数排序的升级版，也是分治算法。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。时间复杂度大约为O(n)，桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排),就是将值为i的元素放到第i个位置，每放一个就给对应的位置加一。当然，如果数据很大并且极为分散，那么可以利用离散化等方法处理。 </p><h3 id="2、桶排序的实现"><a href="#2、桶排序的实现" class="headerlink" title="2、桶排序的实现"></a>2、桶排序的实现</h3><p>初始化数组，读取数据，每读取一个数据，数组对应位置的值加一。 </p><h3 id="3、桶排序的代码实现"><a href="#3、桶排序的代码实现" class="headerlink" title="3、桶排序的代码实现"></a>3、桶排序的代码实现</h3><pre><code>viod Bucket sort()&#123;  int book[1001],i,j,n,k;   cin&gt;&gt;n;   for(i=0;i&lt;=1000;i++)  //创造1000个桶，默认里面都装0个   &#123;  book[i]=0;  &#125;  for(i=0;i&lt;n;i++)   //向对应数字的桶里放数字   &#123;  cin&gt;&gt;k;   book[k]++;  &#125;   for(i=1000;i&gt;=0;i--)    &#123;      for(j=1;j&lt;=book[i];j++)      &#123;      cout&lt;&lt;i&lt;&lt;&quot; &quot;; //检验每个箱子里的个数，0的直接舍弃掉      &#125;    &#125;&#125;</code></pre><h2 id="参考https-blog-csdn-net-m0-64036070-article-details-123826962-ops-request-misc-257B-2522request-255Fid-2522-253A-2522167748254516800227451387-2522-252C-2522scm-2522-253A-252220140713-130102334-2522-257D-amp-request-id-167748254516800227451387-amp-biz-id-0-amp-utm-medium-distribute-pc-search-result-none-task-blog-2-all-top-click-default-2-123826962-null-null-142-v73-control-201-v4-add-ask-239-v2-insert-chatgpt-amp-utm-term-E6-A1-B6-E6-8E-92-E5-BA-8Fc-2B-2B-amp-spm-1018-2226-3001-4187"><a href="#参考https-blog-csdn-net-m0-64036070-article-details-123826962-ops-request-misc-257B-2522request-255Fid-2522-253A-2522167748254516800227451387-2522-252C-2522scm-2522-253A-252220140713-130102334-2522-257D-amp-request-id-167748254516800227451387-amp-biz-id-0-amp-utm-medium-distribute-pc-search-result-none-task-blog-2-all-top-click-default-2-123826962-null-null-142-v73-control-201-v4-add-ask-239-v2-insert-chatgpt-amp-utm-term-E6-A1-B6-E6-8E-92-E5-BA-8Fc-2B-2B-amp-spm-1018-2226-3001-4187" class="headerlink" title="参考https://blog.csdn.net/m0_64036070/article/details/123826962?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167748254516800227451387%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167748254516800227451387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123826962-null-null.142^v73^control,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=%E6%A1%B6%E6%8E%92%E5%BA%8Fc%2B%2B&amp;spm=1018.2226.3001.4187"></a>参考<a href="https://blog.csdn.net/m0_64036070/article/details/123826962?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167748254516800227451387%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167748254516800227451387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123826962-null-null.142%5Ev73%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E6%A1%B6%E6%8E%92%E5%BA%8Fc++&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/m0_64036070/article/details/123826962?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167748254516800227451387%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167748254516800227451387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123826962-null-null.142^v73^control,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=%E6%A1%B6%E6%8E%92%E5%BA%8Fc%2B%2B&amp;spm=1018.2226.3001.4187</a></h2><h2 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a>三、堆排序</h2><hr><h3 id="1、堆排序的简述"><a href="#1、堆排序的简述" class="headerlink" title="1、堆排序的简述"></a>1、堆排序的简述</h3><p>堆是一种叫做完全二叉树的数据结构，可以分为大根堆，小根堆，而堆排序就是基于这种结构而产生的一种程序算法。<br>大根堆:每个节点的值都大于或者等于他的左右孩子节点的值。<br>小根堆:每个结点的值都小于或等于其左孩子和右孩子结点的值。   </p><h3 id="2、堆排序的实现"><a href="#2、堆排序的实现" class="headerlink" title="2、堆排序的实现"></a>2、堆排序的实现</h3><p>1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p><p>2.将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</p><p>3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组</p><p>注意:升序用大根堆，降序就用小根堆 </p><h3 id="3、堆排序的代码实现"><a href="#3、堆排序的代码实现" class="headerlink" title="3、堆排序的代码实现"></a>3、堆排序的代码实现</h3><pre><code>void HeapAdjust(int* arr, int start, int end)  &#123;      int tmp = arr[start];      for (int i = 2 * start + 1; i &lt;= end; i = i * 2 + 1)      &#123;          if (i &lt; end&amp;&amp; arr[i] &lt; arr[i + 1])//有右孩子并且左孩子小于右孩子          &#123;              i++;          &#125;//i一定是左右孩子的最大值          if (arr[i] &gt; tmp)          &#123;              arr[start] = arr[i];              start = i;          &#125;          else          &#123;              break;          &#125;      &#125;      arr[start] = tmp;  &#125;  void HeapSort(int* arr, int len)  &#123;      //第一次建立大根堆，从后往前依次调整      for(int i=(len-1-1)/2;i&gt;=0;i--)      &#123;          HeapAdjust(arr, i, len - 1);      &#125;      //每次将根和待排序的最后一次交换，然后在调整      int tmp;      for (int i = 0; i &lt; len - 1; i++)      &#123;          tmp = arr[0];          arr[0] = arr[len - 1-i];          arr[len - 1 - i] = tmp;          HeapAdjust(arr, 0, len - 1-i- 1);      &#125;  &#125;  int main()  &#123;      int arr[] = &#123; 9,5,6,3,5,3,1,0,96,66 &#125;;      HeapSort(arr, sizeof(arr) / sizeof(arr[0]));      printf(&quot;排序后为:&quot;);      for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]);   i++)      &#123;          printf(&quot;%d &quot;, arr[i]);      &#125;      return 0;  &#125;  </code></pre><p>参考 <a href="https://blog.csdn.net/weixin_51609435/article/details/122982075?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167748309116782425644627%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167748309116782425644627&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122982075-null-null.142%5Ev73%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_51609435/article/details/122982075?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167748309116782425644627%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167748309116782425644627&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122982075-null-null.142^v73^control,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F&amp;spm=1018.2226.3001.4187</a></p><hr><h2 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h2><hr><h3 id="1、插入排序的简述"><a href="#1、插入排序的简述" class="headerlink" title="1、插入排序的简述"></a>1、插入排序的简述</h3><p>把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，在有序表中从后往前进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h3 id="2、插入排序的实现"><a href="#2、插入排序的实现" class="headerlink" title="2、插入排序的实现"></a>2、插入排序的实现</h3><p>1.从第一个元素开始，该元素可以认为已经被排序<br>2.取下一个元素tem，从已排序的元素序列从后往前扫描<br>3.如果该元素大于tem，则将该元素移到下一位<br>4.重复步骤3，直到找到已排序元素中小于等于tem的元素<br>5.tem插入到该元素的后面，如果已排序所有元素都大于tem，则将tem插入到下标为0的位置<br>6.重复步骤2~5   </p><h3 id="3、插入排序的代码实现"><a href="#3、插入排序的代码实现" class="headerlink" title="3、插入排序的代码实现"></a>3、插入排序的代码实现</h3><pre><code>void InsertSort(int* arr, int n)&#123;    for (int i = 0; i &lt; n - 1; ++i)    &#123;        //记录有序序列最后一个元素的下标        int end = i;        //待插入的元素        int tem = arr[end + 1];        //单趟排        while (end &gt;= 0)        &#123;            //比插入的数大就向后移            if (tem &lt; arr[end])            &#123;                arr[end + 1] = arr[end];                end--;            &#125;            //比插入的数小，跳出循环            else            &#123;                break;            &#125;        &#125;        //tem放到比插入的数小的数的后面        arr[end  + 1] = tem;        //代码执行到此位置有两种情况:        //1.待插入元素找到应插入位置（break跳出循环到此）        //2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）    &#125;&#125;</code></pre><p>参考<a href="https://blog.csdn.net/weixin_50886514/article/details/119045154">https://blog.csdn.net/weixin_50886514/article/details/119045154</a> </p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2023/02/27/%E6%8E%92%E5%BA%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于个人博客搭建的一些纠正与建议</title>
      <link>http://example.com/2022/10/24/hello-world%20-%20%E5%89%AF%E6%9C%AC/</link>
      <guid>http://example.com/2022/10/24/hello-world%20-%20%E5%89%AF%E6%9C%AC/</guid>
      <pubDate>Mon, 24 Oct 2022 00:23:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;具体教程详见枫叶大神的博客，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102592286&quot;&gt;https://zhuanlan.zhihu.com/p/102592286&lt;/a&gt;，本篇只是对其中的一些步骤和本人搭建个人博客过程中遇到的问题提供</description>
        
      
      
      
      <content:encoded><![CDATA[<p>具体教程详见枫叶大神的博客，<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a>，本篇只是对其中的一些步骤和本人搭建个人博客过程中遇到的问题提供改进以及解决方法。</p><hr><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="第三篇"><a href="#第三篇" class="headerlink" title="第三篇"></a>第三篇</h3><p>输入用户名和邮箱时，要先输入邮箱。最后一步，将master改成main即可。</p><h3 id="第五篇"><a href="#第五篇" class="headerlink" title="第五篇"></a>第五篇</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repository: https://github.com/fengye97/fengye97.github.io.git  <span class="comment">#你的仓库地址</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>在填这个时，要将前两行删除，否则会报错，最后面要修改成main。</p><p>在建立两个文件夹node_global与node_caceh时，需要右键设置“属性”，将用户具有完全属性的权限或者直接以管理员身份运行cmd，遇见 hexo command not found的同学，可以在path环境变量中新增一个D:\Blog\node_modules\hexo-cli\bin，是你对应安装的hexo的路径。</p><h3 id="第七篇"><a href="#第七篇" class="headerlink" title="第七篇"></a>第七篇</h3><p>如果每次更换完主题后，都要到github项目里面的setting设置custom domain为自己的域名，那应该是CNAME文件后缀.txt没有去掉。</p><h3 id="第八篇"><a href="#第八篇" class="headerlink" title="第八篇"></a>第八篇</h3><p>进行主题优化时，尽量一步步来，每次之后hexo三部曲，才能更好的发现问题。hexo三部曲后，会有网络延迟等原因，导致无法显示，是正常现象，可以试试清除浏览器缓存（注意不要删除Cookie和其他站点数据）。</p><h3 id="Ps-过程中或许会遇到一些网络问题，这时候就需要一些玄学了-（马伟昊-2022211401-2022211314）"><a href="#Ps-过程中或许会遇到一些网络问题，这时候就需要一些玄学了-（马伟昊-2022211401-2022211314）" class="headerlink" title="Ps:过程中或许会遇到一些网络问题，这时候就需要一些玄学了~~（马伟昊-2022211401-2022211314）"></a>Ps:过程中或许会遇到一些网络问题，这时候就需要一些玄学了~~（马伟昊-2022211401-2022211314）</h3>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/10/24/hello-world%20-%20%E5%89%AF%E6%9C%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://example.com/2022/10/12/hello-world/</link>
      <guid>http://example.com/2022/10/12/hello-world/</guid>
      <pubDate>Wed, 12 Oct 2022 11:12:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/10/12/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
